searchState.loadedDescShard("m5dial_bsp", 0, "M5 Dial Board Support Package (BSP)\nInitialize board peripherals from ESP32 peripherals.\nM5Dial Board Support Package\nRT3267 Touch driver\nGet the buzzer\nGet rottary encoder\nGet the Port.A external I2C bus\nGet PORT.B input (white wire)\nGet PORT.B output (yellow wire)\nGet screen controller\nGet the touch screen controller\nBright predefined brightness level\nBrightest predefined brightness level\nMarker type signalling that a driver is initialized in …\nStruct that holds display brightness\nBuffer type Sized\nBuffered Graphic Implementation\nThe driver maximum cols\nDim predefined brightness level\nDimmest predefined brightness level\nDefault implementation of <code>Phase</code>.\nDelay driver, using <code>Instant</code>.\nScreen information\nScreen Definition Resolution 240 x 240\nScreen Rotation\nPull down\nThe type representing errors that may occur during display …\nI2C driver\n<code>SpiDevice</code> implementation with exclusive access to the bus …\nGc9a01 Driver\nThe screen/pixels maximum height (Y)\nHigh\nI2C driver configuration\nDigital input.\nInput pin configuration.\nLEDC (LED PWM Controller)\nDigital input or output level.\nLow\nHolds the board peripherals\nDefine a type alias for the display\nSPI communication modes, defined by clock polarity (CPOL) …\nMedium predefined brightness level\nDummy <code>DelayNs</code> implementation that panics on use.\nNo pull\nThe screen X offset\nThe screen Y offset\nPush-pull digital output.\nOutput pin configuration.\nTrait implemented by pins which can be used as outputs.\nPull setting for a GPIO.\nThe driver maximum rows\nRepresents a rate or frequency of events.\nHolds current/old state and both <code>InputPin</code>\nSPI Interfaces for the screen\nSPI display interface.\nSPI peripheral driver\nSPI peripheral configuration\nPull up\nThe screen/pixels maximum width (X)\nThis trait implements a write-only interface for a display …\nMode 0 (CPOL = 0, CPHA = 0): Clock is low when idle, data …\nMode 1 (CPOL = 0, CPHA = 1): Clock is low when idle, data …\nMode 2 (CPOL = 1, CPHA = 0): Clock is high when idle, data …\nMode 3 (CPOL = 1, CPHA = 1): Clock is high when idle, data …\nChange the configuration.\nChange the configuration.\nApplies a new configuration.\nChange the bus configuration.\nConvert the <code>Rate</code> to a <code>Duration</code>.\nConvert the <code>Rate</code> to an interger number of Hz.\nConvert the <code>Rate</code> to an interger number of kHz.\nConvert the <code>Rate</code> to an interger number of MHz.\nSend the data to the display for drawing at the current …\nGet pixel screen bounds (x-1, y-1)\nReturns the brightness as a <code>u8</code>.\nReturns a reference to the underlying bus object.\nReturns a mutable reference to the underlying bus object.\nReturn a new channel\nClear the display buffer NOTE: Must use <code>flush</code> to apply …\nClear the display\nClears the screen by sending a zeroed buffer using a …\nClears the screen by sending a zeroed buffer using a …\nClear the interrupt status bit for this Pin\nResets asserted interrupts\nThe clock source\nConfiguration hook to configure model-dependent …\nQuery if the touch screen is touched. If touch screen is …\nCreate a new <code>Brightness</code> from a custom raw input\nDelay for the specified time\nDelay for the specified number of microseconds\nDelay for the specified number of milliseconds\nDelay for the specified number of nanoseconds\nGet pixel screen dimensions\nSend a raw buffer to the screen.\nSend a raw buffer to the screen.\nOutput drive mode.\nPin drive strength.\nWrite the display buffer\nWaits for the completion of previous operations.\nThe I2C clock frequency.\nThe target frequency\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nShorthand for creating a rate which represents hertz.\nShorthand for creating a rate which represents kilohertz.\nShorthand for creating a rate which represents megahertz.\nGet screen rotation\nHalf-duplex read.\nHalf-duplex write.\nQuery if button state has changed since last call.\nInitializes and configures the display for the given mode.\nInitialise and clear the display in graphics mode.\nInitialise and clear the display in graphics mode.\nInitialise the screen in one of the available addressing …\nGets asserted interrupts\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReconfigures the driver to operate in <code>Async</code> mode.\nReconfigures the driver to operate in <code>Async</code> mode.\nReconfigures the driver to operate in <code>Blocking</code> mode.\nReconfigures the driver to operate in <code>Blocking</code> mode.\nConvert the display into a buffered graphics mode, …\nConverts the pin driver into a <code>Flex</code> driver.\nConverts the pin driver into a <code>Flex</code> driver.\nConsumes this <code>Rotary</code>, returning the underlying pins <code>A</code> and <code>B</code>…\nTurns the pin object into a peripheral output.\nQuery current button state\nGet whether the pin input level is high.\nChecks if the interrupt status bit for this Pin is set\nGet whether the pin input level is low.\nReturns whether the pin is set to high level.\nReturns whether the pin is set to low level.\nGet the current pin input level.\nListen for interrupts.\nListen for the given interrupts\nSPI sample/shift mode.\nAccepts two <code>InputPin</code>s, these will be read on every <code>update()</code>\nCreate new SPI interface for communication with a display …\nCreate a new <code>ExclusiveDevice</code>.\nCreate a basic <code>Gc9a01</code> interface.\nCreates a new GPIO output driver.\nCreates a new GPIO input.\nCreate a new I2C instance.\nConstructs an SPI instance in 8bit dataframe mode.\nReturn a new LEDC\nCreates a new <code>Delay</code> instance.\nCreate a new <code>ExclusiveDevice</code> without support for …\nReturns which level the pin is set to.\nReturns a peripheral input connected to this pin.\nReturns a reference to the first pin. Can be used to clear …\nReturns a reference to the second pin. Can be used to …\nReturns a reference to both pins. Can be used to clear …\nGet Finger position for finger ‘n’.\nPin pull direction.\nInitial pull of the pin.\nReads enough bytes from slave with <code>address</code> to fill <code>buffer</code>\nRead bytes from SPI. The provided slice is filled with …\nReads enough bytes from slave with <code>address</code> to fill <code>buffer</code>.\nBit order of the read data.\nConsume the display interface and return the underlying …\nReset the display.\nSets the threshold for the unchanged duration of the …\nSets the threshold value for the unchanged period of the …\nSend a batch of commands to display\nSend pixel data to display\nScreen backlight control\nChange the display brightness.\nSet the screen rotation.\nSet hardware framebuffer to configure a limited area of …\nSet global slow clock source\nSet the output as high.\nRegisters an interrupt handler for the peripheral on the …\nRegisters an interrupt handler for the peripheral on the …\nSets the interrupt handler\nSet hardware to inverse the GDDRAM framebuffer output\nSet the output level.ç\nSet the output as low.\nSet a pixel color at <code>x</code> and <code>y</code> coordinates directly through …\nSet a pixel color. If the X and Y coordinates are out of …\nSet the pixels directly to the hardware by setting the …\nSet the pixels\nSets the rotation of the display.\nSet display rotation\nSet the display rotation.\nSet hardware screen state\nSet the hardware framebuffer to await incoming colors\nShutdown the board.\nSoftware timeout.\nI2C SCL timeout period.\nReturn a new timer\nToggles the pin output.\nExecute the provided operations on the I2C bus.\nExecute the provided operations on the I2C bus as a single …\nSends <code>words</code> to the slave. The received data will be …\nSends <code>words</code> to the slave. Returns the <code>words</code> received from …\nStop listening for interrupts\nUnlisten the given interrupts\nCall <code>update</code> to evaluate the next state of the encoder, …\nWait until the pin experiences a particular <code>Event</code>.\nWait for the pin to undergo any transition, i.e low to …\nWait for the pin to undergo a transition from high to low.\nWait until the pin is high.\nWait until the pin is low.\nWait for the pin to undergo a transition from low to high.\nEnable as a wake-up source.\nSet the clock source of the SPI bus.\nAssign the CS (Chip Select) pin for the SPI instance.\nConfigures the SPI instance to use DMA with the specified …\nAssign the given value to the <code>drive_mode</code> field.\nAssign the given value to the <code>drive_strength</code> field.\nAssign the given value to the <code>frequency</code> field.\nSet the frequency of the SPI bus clock.\nAssign the MISO (Master In Slave Out) pin for the SPI …\nAssign the given value to the <code>mode</code> field.\nAssign the MOSI (Master Out Slave In) pin for the SPI …\nAccepts two <code>InputPin</code>s, these will be read on every <code>update()</code>…\nAssign the given value to the <code>pull</code> field.\nAssign the given value to the <code>pull</code> field.\nAssign the given value to the <code>read_bit_order</code> field.\nAssign the SCK (Serial Clock) pin for the SPI instance.\nConnect a pin to the I2C SCL signal.\nAssign the given value to the <code>scl_main_st_timeout</code> field.\nAssign the given value to the <code>scl_st_timeout</code> field.\nConnect a pin to the I2C SDA signal.\nAssign the SIO0 pin for the SPI instance.\nAssign the SIO1/MISO pin for the SPI instance.\nAssign the SIO2 pin for the SPI instance.\nAssign the SIO3 pin for the SPI instance.\nAssign the SIO4 pin for the SPI instance.\nAssign the SIO5 pin for the SPI instance.\nAssign the SIO6 pin for the SPI instance.\nAssign the SIO7 pin for the SPI instance.\nAssign the given value to the <code>software_timeout</code> field.\nAssign the given value to the <code>timeout</code> field.\nAssign the given value to the <code>write_bit_order</code> field.\nWrites bytes to slave with given <code>address</code>\nWrite bytes to SPI. After writing, flush is called to …\nWrites bytes to slave with given <code>address</code>.\nBit order of the written data.\nWrites bytes to slave with given <code>address</code> and then reads …\nWrites bytes to slave with given <code>address</code> and then reads …\nBuzzer driver using LEDC peripheral to generate the PWM …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBuild a new buzzer driver.\nTurn the buzzer OFF\nSet buzzing frequency, in Hz\nFT3267 Driver.\nTouch point coordinate.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the coordinate of a touch point\nTouch point id, used on multitouch to distinguish touch …\nInitialize the driver IC.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBuild a new FT3257 driver\nPool if the touch screen is touched.\nTouch point X coordinate.\nTouch point Y coordinate.")